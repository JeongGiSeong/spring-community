학습하면서 얻은 지식이나 헷갈렸던 부분을 정리합니다.

---

## Spring Security
<br>

### Session 방식으로 로그인 구현
    로그인을 통해 사용자를 확인한 후 회원 정보를 세션에 저장한 후 이와 연결되는 세션 ID를 발급.
    이후 클라이언트는 매 요청마다 header에 세션 ID가 담긴 쿠키를 넣어 통신하는 방식으로 인증.
    
    장점
    - 서버에서 사용자의 인증 상태를 관리하기 때문에 보안성이 높다.
    - 쿠키에는 세션 ID만 저장되므로 개인 정보가 노출될 위험이 적다.
    - 세션 ID를 통해 사용자의 정보를 쉽게 조회할 수 있다.
    
    단점
    - 서버의 메모리를 많이 차지하므로 부하가 커질 수 있다.
    - 세션 ID가 탈취되면 보안이 취약해질 수 있다.
    - 세션 ID가 만료되면 다시 로그인해야 한다. 
<br>


### UserDetails, UserDetailsService
#### UserDetails
    Spring Security에서 사용자의 정보를 담는 인터페이스. 
    이 인터페이스를 통해 사용자의 정보를 저장하고, Spring Security의 다른 컴포넌트에서 이 정보를 참조할 수 있습니다.

    getUsername(): 사용자의 이름을 반환
    getPassword(): 사용자의 비밀번호를 반환
    getAuthorities(): 사용자의 권한을 반환. 권한은 GrantedAuthority 인터페이스를 구현한 객체의 컬렉션으로 표현
    isEnabled(), isAccountNonLocked(), isAccountNonExpired(), isCredentialsNonExpired(): 사용자 계정의 활성화 상태, 잠금 상태, 만료 상태 등을 확인하는 메소드
<br>

#### UserDetailsService
    Spring Security에서 사용자의 정보를 가져오는 인터페이스. 

    loadUserByUsername(String username): 로그인 시도 시 호출. 주어진 사용자 이름에 해당하는 사용자 정보를 UserDetails 객체로 반환
<br>

### CSRF(Cross Site Request Forgery)
    웹 어플리케이션에서 발생하는 취약점 중 하나. 로그인 한 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하도록 만드는 공격 방법
    REST API 서버라면 stateless하기 때문에 굳이 CSRF 보호 기능을 사용할 필요가 없다.

    예시) 사용자가 은행 웹사이트에서 송금을 하려고 합니다. 공격자는 다음과 같은 URL을 만들어 사용자가 클릭하도록 유도할 수 있습니다.
    http://bank.com/fund?acct=224224&amount=50000
    이 URL은 사용자가 은행 웹사이트에 로그인한 상태에서 방문하면, 사용자의 이름으로 $50,000를 공격자의 계좌(#224224)로 송금하게 됩니다.
<br>

#### CSRF 토큰 검증 원리
    CSRF 토큰을 클라이언트와 공유하는 일반적인 방법은 HTML 형식의 숨겨진 매개변수로 포함
    CSRF 토큰은 서버에서 임의의 난수를 생성하고 사용자의 세션에 저장합니다.
    사용자의 모든 요청에 이 난수 값을 포함하여 전송하도록 합니다.
    서버에서는 요청을 받을 때마다 세션에 저장된 토큰 값과 요청 파라미터에 전달된 토큰 값이 일치하는지 검증합니다.
    이 방법을 통해 서버는 사용자의 요청이 실제로 사용자가 전송한 것인지 확인합니다.
<br>

#### CSRF 토큰의 작동 순서
    1. 사용자가 웹사이트에 접속하면, 서버는 CSRF 토큰을 생성합니다. 이 토큰은 보통 HTML form의 hidden 필드에 포함되어 사용자에게 전달됩니다.
    2. 동시에, 서버는 같은 토큰 값을 사용자의 세션에 저장합니다.
    3. 사용자가 form을 제출하거나 어떤 요청을 보낼 때, 요청에는 세션에 저장된 CSRF 토큰이 포함됩니다. 이 토큰은 보통 HTTP header나 body에 포함됩니다.
    4. 서버는 요청을 받으면, 요청에 포함된 CSRF 토큰과 세션에 저장된 CSRF 토큰을 비교합니다. 두 토큰이 일치하면 요청이 유효한 것으로 판단하고, 그렇지 않으면 요청을 거부합니다.
<br>

## 조회수 중복 방지
<br>

### 쿠키/로컬 스토리지 사용
    사용자가 특정 페이지를 방문할 때, 해당 페이지의 고유 식별자를 쿠키나 로컬 스토리지에 저장합니다. 다음에 같은 페이지를 방문할 때, 저장된 식별자를 확인하여 조회수를 증가시키지 않습니다.

    장점
     - 구현이 간단하고 쉽습니다.
     - 서버 측 부하가 적습니다.
    단점
     - 사용자가 쿠키나 로컬 스토리지를 삭제하거나, 다른 브라우저를 사용할 경우 중복 카운트가 발생할 수 있습니다.
     - 보안 면에서 취약할 수 있습니다.
<br>

### 서버 측 세션 활용
    사용자의 세션에 페이지 방문 정보를 저장하여, 동일 세션 내에서는 페이지 조회수를 중복으로 증가시키지 않습니다.

    장점
     - 쿠키보다 보안이 강화됩니다.
     - 사용자가 쿠키를 삭제해도 영향을 받지 않습니다.

    단점
     - 서버에 부하를 줄 수 있습니다.
     - 사용자가 여러 기기나 브라우저를 사용할 경우 여전히 중복 카운트가 발생할 수 있습니다.
<br>

### IP 주소와 사용자 에이전트 기반
    용자의 IP 주소와 사용자 에이전트(User-Agent) 정보를 조합하여 고유 식별자를 생성하고, 이를 기반으로 중복 조회를 판단합니다.

    장점
     - 다양한 브라우저와 기기에서의 중복 조회수 증가를 어느 정도 방지할 수 있습니다.

    단점
     - 동일 네트워크(예: 학교, 회사)를 사용하는 사용자들은 같은 IP를 공유할 수 있어 정확도가 떨어질 수 있습니다.
     - 사용자의 개인정보 보호 정책에 따라 IP 주소 사용이 제한될 수 있습니다.
<br>

### 토큰 기반 인증 활용
    사용자 인증 시 발급되는 토큰(예: JWT)을 활용하여, 인증된 사용자의 각 요청을 식별하고 중복 조회수를 방지합니다.

    장점
     - 보안성이 높고, 사용자별 데이터 추적이 용이합니다.

    단점
     - 인증이 필요 없는 공개적인 컨텐츠에는 적합하지 않을 수 있습니다.
     - 구현 복잡도가 상대적으로 높습니다.